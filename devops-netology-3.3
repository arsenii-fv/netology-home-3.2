1.
Выполняется системный вызов:
chdir("/tmp")	=0 с кодом возврата 0, успешное выполние

2.
penat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3

3.
cat /dev/null > /tmp/not_del_me

4.
Зомби процессы не занимают ресурсы ОС (CPU, RAM, IO) Ядро поддерживает мин набор информации о зомби PID, статус, информацию об использовании ресурсов. Но зомби процессы занимают место в таблице процессов ядра, если она заполнится то новые процессы создаваться не будут.

5.
; - после этого символа выполняется следующая команда, т.е. последовательное выполнение команд в одной строке. && логическое И , при успешном выполнении предыдущей команды будет выполнена следующая. set -e полностью прерывает выполнение команд при неуспешном выполнении предыдущей. Да при выполнении команд последовательно set -e можно заменить && , если в скрипте то в этом случае будет выход из скрипта что возможно не желательно.

6.
Part of the utsname information is also accessible via /proc/sys/kernel/{ostype, hostname, osrelease, version, domainname}

7.


8.
https://silentsokolov.github.io/safe-bash-sctipts -e полностью прерывает выполнение сценария при неуспешном выполнении предыдущей команды. -u оболочка проверяет инициализацию переменных в скрипте. Если переменной не будет, скрипт немедленно завершиться. -x печатает в стандартный вывод все команды перед их исполнением -o Bash возвращает только код ошибки последней команды в пайпе (конвейере), а параметр -e проверяет только его.


